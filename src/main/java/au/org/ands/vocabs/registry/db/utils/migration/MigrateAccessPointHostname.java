/** See the file "LICENSE" for the full license governing this code. */

package au.org.ands.vocabs.registry.db.utils.migration;

import java.lang.invoke.MethodHandles;
import java.time.LocalDateTime;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.EntityTransaction;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import au.org.ands.vocabs.registry.db.context.DBContext;
import au.org.ands.vocabs.registry.db.context.TemporalUtils;
import au.org.ands.vocabs.registry.db.converter.JSONSerialization;
import au.org.ands.vocabs.registry.db.dao.AccessPointDAO;
import au.org.ands.vocabs.registry.db.entity.AccessPoint;
import au.org.ands.vocabs.registry.db.entity.clone.AccessPointClone;
import au.org.ands.vocabs.registry.db.internal.ApApiSparql;
import au.org.ands.vocabs.registry.db.internal.ApFile;
import au.org.ands.vocabs.registry.db.internal.ApSesameDownload;
import au.org.ands.vocabs.registry.db.internal.ApSissvoc;

/** Standalone program to change the hostname used within
 * access points. This is not a generic rewriting program;
 * for example, as you will see, we rewrite both http and https to https.
 * The following fields are affected:
 * <ul>
 * <li>type = API_SPARQL, source = SYSTEM or USER: in the field "url", replace
 *   http://demo.ands.org.au/repository/api/sparql...
 *   and
 *   https://demo.ands.org.au/repository/api/sparql...
 *   with:
 *   https://demo.vocabs.ardc.edu.au/repository/api/sparql...
 * </li>
 * <li>type = FILE (source = USER): in the field "url", replace
 *   http://demo.ands.org.au/vocabs-registry/api/resource/downloads/...
 *   and
 *   https://demo.ands.org.au/vocabs-registry/api/resource/downloads/...
 *   with:
 *   https://demo.vocabs.ardc.edu.au/registry/api/resource/downloads/...</li>
 * <li>type = SESAME_DOWNLOAD (source = SYSTEM or USER): in the field
 *   "server-base", replace
 *   http://demo.ands.org.au/repository/openrdf-sesame/
 *   and
 *   http://demo.ands.org.au/repository/openrdf-sesame/
 *   with
 *   http://demo.vocabs.ardc.edu.au/repository/openrdf-sesame/
 *   and in the field "url-prefix", replace
 *   http://demo.ands.org.au/vocabs-registry/api/resource/downloads/...
 *   and
 *   https://demo.ands.org.au/vocabs-registry/api/resource/downloads/...
 *   with
 *   https://demo.vocabs.ardc.edu.au/registry/api/resource/downloads/...
 * </li>
 * <li>type = SISSVOC (source = SYSTEM or USER): in the field "url-prefix",
 *   replace
 *   http://demo.ands.org.au/repository/api/lda...
 *   and
 *   http://demo.ands.org.au/repository/api/lda...
 *   with
 *   http://demo.vocabs.ardc.edu.au/repository/api/lda...
 * </li>
 * </ul>
 * <p>Here is a suggested way to use this program.</p>
 * <pre> ant migrate-accesspoint-hostname &gt; migrate-out.txt</pre>
 *
 */
public final class MigrateAccessPointHostname {

    /** Logger for this class. */
    private static Logger logger = LoggerFactory.getLogger(
            MethodHandles.lookup().lookupClass());

    /** Private constructor for a standalone program. */
    private MigrateAccessPointHostname() {
    }

    /** Create tasks to remove all currently-valid version artefacts
     * generated by the JsonTreeTransformProvider and
     * replace them with new ones using the ConceptTreeTransformProvider.
     * @param args Command-line parameters. None are expected.
     */
    // Magic number errors generated for argument positions 3 and greater.
    @SuppressWarnings("checkstyle:MagicNumber")
    public static void main(final String[] args) {
        logger.info("Starting MigrateAccessPointHostname");

        if (args.length != 8) {
            logger.error("Must provide eight command-line parameters");
            return;
        }

        // e.g., demo.ands.org.au/repository/openrdf-sesame/
        String beforeSesame = args[0];
        // e.g., demo.vocabs.ardc.edu.au/repository/openrdf-sesame/
        String afterSesame = args[1];
        // e.g., demo.ands.org.au/vocabs-registry/api/resource/downloads/
        String beforeRegistryDownloads = args[2];
        // e.g., demo.vocabs.ardc.edu.au/registry/api/resource/downloads/
        String afterRegistryDownloads = args[3];
        // e.g., demo.ands.org.au/repository/api/sparql
        String beforeRepositorySparql = args[4];
        // e.g., demo.vocabs.ardc.edu.au/repository/api/sparql
        String afterRepositorySparql = args[5];
        // e.g., demo.ands.org.au/repository/api/lda
        String beforeRepositoryLda = args[6];
        // e.g., demo.vocabs.ardc.edu.au/repository/api/lda
        String afterRepositoryLda = args[7];

        // e.g., demo.ands.org.au/vocabs-registry/api/resource/downloads/
        String beforeSesameRegex = "https?://"
                + beforeSesame;
        // e.g., demo.vocabs.ardc.edu.au/registry/api/resource/downloads/
        String afterSesameReplacement = "https://"
                + afterSesame;
        // e.g., demo.ands.org.au/vocabs-registry/api/resource/downloads/
        String beforeRegistryDownloadsRegex = "https?://"
                + beforeRegistryDownloads;
        // e.g., demo.vocabs.ardc.edu.au/registry/api/resource/downloads/
        String afterRegistryDownloadsReplacement = "https://"
                + afterRegistryDownloads;
        // e.g., demo.ands.org.au/repository/api/sparql
        String beforeRepositorySparqlRegex = "https?://"
                + beforeRepositorySparql;
        // e.g., demo.vocabs.ardc.edu.au/repository/api/sparql
        String afterRepositorySparqlReplacement = "https://"
                + afterRepositorySparql;
        // e.g., demo.ands.org.au/repository/api/lda
        String beforeRepositoryLdaRegex = "https?://"
                + beforeRepositoryLda;
        // e.g., demo.vocabs.ardc.edu.au/repository/api/lda
        String afterRepositoryLdaReplacement = "https://"
                + afterRepositoryLda;

        AccessPointClone apCloneMapper = AccessPointClone.INSTANCE;

        EntityManager em = null;
        EntityTransaction txn = null;

        try {
            em = DBContext.getEntityManager();
            txn = em.getTransaction();
            txn.begin();

            // Timestamp to use for start/end date values.
            LocalDateTime now = TemporalUtils.nowUTC();

            // We want both current and draft instances.
            List<AccessPoint> apList =
                    AccessPointDAO.getAllCurrentAccessPoint();
            apList.addAll(AccessPointDAO.getAllDraftAccessPoint());
            for (AccessPoint ap : apList) {
                switch (ap.getType()) {
                case API_SPARQL:
                    fixApiSparql(em, now, beforeRepositorySparqlRegex,
                            afterRepositorySparqlReplacement,
                            apCloneMapper, ap);
                    break;
                case FILE:
                    fixFile(em, now, beforeRegistryDownloadsRegex,
                            afterRegistryDownloadsReplacement,
                            apCloneMapper, ap);
                    break;
                case SESAME_DOWNLOAD:
                    fixSesameDownload(em, now,
                            beforeSesameRegex, afterSesameReplacement,
                            beforeRegistryDownloadsRegex,
                            afterRegistryDownloadsReplacement,
                            apCloneMapper, ap);
                    break;
                case SISSVOC:
                    fixSissvoc(em, now, beforeRepositoryLdaRegex,
                            afterRepositoryLdaReplacement, apCloneMapper, ap);
                    break;
                case WEB_PAGE:
                    // We don't touch web page access points.
                    break;
                default:
                    logger.error("Unknown access point type: " + ap.getType());
                    continue;
                }
            }
            txn.commit();
        } catch (Throwable t) {
            if (txn != null && txn.isActive()) {
                try {
                    logger.error("Exception during transaction; rolling back",
                            t);
                    txn.rollback();
                } catch (Exception e) {
                    logger.error("Rollback failure!", e);
                }
            } else {
                logger.error("Exception, either during rollback, or "
                        + "outside active transaction", t);
            }
            // Otherwise, don't throw, but fall through so that the user sees
            // an error message.
        } finally {
            if (em != null) {
                em.close();
            }
        }

    }

    /** Examine an apiSparql access point to see if it needs updating;
     * if so, make the existing instance historical, and add a new instance.
     * @param em The EntityManager to be used.
     * @param now The time to use as the value of "now" when
     *      applying changes to rows of the database.
     * @param beforeRepositorySparqlRegex The regular expression to use
     *      for finding a match within the "url" field.
     * @param afterRepositorySparqlReplacement The replacement value to use
     *      for matches within the "url" field.
     * @param apCloneMapper The mapper instance to use for cloning
     *      AccessPoint instances.
     * @param ap The access point to consider fixing.
     */
    public static void fixApiSparql(final EntityManager em,
            final LocalDateTime now,
            final String beforeRepositorySparqlRegex,
            final String afterRepositorySparqlReplacement,
            final AccessPointClone apCloneMapper,
            final AccessPoint ap) {
        ApApiSparql apApiSparql =
                JSONSerialization.deserializeStringAsJson(ap.getData(),
                        ApApiSparql.class);
        String oldUrl = apApiSparql.getUrl();
        String newUrl = oldUrl.replaceFirst(beforeRepositorySparqlRegex,
                afterRepositorySparqlReplacement);
        if (newUrl != oldUrl) {
            logger.info("For apiSparql access point, replacing "
                    + "url |" + oldUrl + "| with |" + newUrl + "|");
            if (TemporalUtils.isCurrent(ap)) {
                AccessPoint newAP = apCloneMapper.clone(ap);
                TemporalUtils.makeHistorical(ap, now);
                AccessPointDAO.updateAccessPoint(em, ap);
                ApApiSparql newApApiSparql = apCloneMapper.clone(apApiSparql);
                newApApiSparql.setUrl(newUrl);
                newAP.setData(JSONSerialization.serializeObjectAsJsonString(
                        newApApiSparql));
                TemporalUtils.makeCurrentlyValid(newAP, now);
                AccessPointDAO.saveAccessPoint(em, newAP);
            } else {
                apApiSparql.setUrl(newUrl);
                ap.setData(JSONSerialization.serializeObjectAsJsonString(
                        apApiSparql));
                AccessPointDAO.updateAccessPoint(em, ap);
            }
        } else {
            logger.info("For apiSparql access point, leaving "
                    + "url |" + oldUrl + "| unchanged");
        }
    }

    /** Examine a file access point to see if it needs updating;
     * if so, make the existing instance historical, and add a new instance.
     * @param em The EntityManager to be used.
     * @param now The time to use as the value of "now" when
     *      applying changes to rows of the database.
     * @param beforeRegistryDownloadsRegex The regular expression to use
     *      for finding a match within the "url" field.
     * @param afterRegistryDownloadsReplacement The replacement value to use
     *      for matches within the "url" field.
     * @param apCloneMapper The mapper instance to use for cloning
     *      AccessPoint instances.
     * @param ap The access point to consider fixing.
     */
    public static void fixFile(final EntityManager em,
            final LocalDateTime now,
            final String beforeRegistryDownloadsRegex,
            final String afterRegistryDownloadsReplacement,
            final AccessPointClone apCloneMapper,
            final AccessPoint ap) {
        ApFile apFile =
                JSONSerialization.deserializeStringAsJson(ap.getData(),
                        ApFile.class);
        String oldUrl = apFile.getUrl();
        if (TemporalUtils.isDraft(ap) && oldUrl == null) {
            // If this is a draft record, there may be no "url" field.
            // In that case, return;
            return;
        }
        String newUrl = oldUrl.replaceFirst(
                beforeRegistryDownloadsRegex,
                afterRegistryDownloadsReplacement);
        if (newUrl != oldUrl) {
            logger.info("For file access point, replacing "
                    + "url |" + oldUrl + "| with |" + newUrl + "|");
            if (TemporalUtils.isCurrent(ap)) {
                AccessPoint newAP = apCloneMapper.clone(ap);
                TemporalUtils.makeHistorical(ap, now);
                AccessPointDAO.updateAccessPoint(em, ap);
                ApFile newApFile = apCloneMapper.clone(apFile);
                newApFile.setUrl(newUrl);
                newAP.setData(JSONSerialization.serializeObjectAsJsonString(
                        newApFile));
                TemporalUtils.makeCurrentlyValid(newAP, now);
                AccessPointDAO.saveAccessPoint(em, newAP);
            } else {
                apFile.setUrl(newUrl);
                ap.setData(JSONSerialization.serializeObjectAsJsonString(
                        apFile));
                AccessPointDAO.updateAccessPoint(em, ap);
            }
        } else {
            logger.info("For file access point, leaving "
                    + "url |" + oldUrl + "| unchanged");
        }
    }

    /** Examine a sesameDownload access point to see if it needs updating;
     * if so, make the existing instance historical, and add a new instance.
     * @param em The EntityManager to be used.
     * @param now The time to use as the value of "now" when
     *      applying changes to rows of the database.
     * @param beforeSesameRegex The regular expression to use
     *      for finding a match within the "server-base" field.
     * @param afterSesameReplacement The replacement value to use
     *      for matches within the "server-base" field.
     * @param beforeRegistryDownloadsRegex The regular expression to use
     *      for finding a match within the "url-prefix" field.
     * @param afterRegistryDownloadsReplacement The replacement value to use
     *      for matches within the "url-prefix" field.
     * @param apCloneMapper The mapper instance to use for cloning
     *      AccessPoint instances.
     * @param ap The access point to consider fixing.
     */
    @SuppressWarnings("checkstyle:ParameterNumber")
    public static void fixSesameDownload(final EntityManager em,
            final LocalDateTime now,
            final String beforeSesameRegex,
            final String afterSesameReplacement,
            final String beforeRegistryDownloadsRegex,
            final String afterRegistryDownloadsReplacement,
            final AccessPointClone apCloneMapper,
            final AccessPoint ap) {
        ApSesameDownload apSesameDownload =
                JSONSerialization.deserializeStringAsJson(ap.getData(),
                        ApSesameDownload.class);
        String oldServerBase = apSesameDownload.getServerBase();
        String newServerBase = oldServerBase.replaceFirst(
                beforeSesameRegex,
                afterSesameReplacement);
        String oldUrlPrefix = apSesameDownload.getUrlPrefix();
        String newUrlPrefix = oldUrlPrefix.replaceFirst(
                beforeRegistryDownloadsRegex,
                afterRegistryDownloadsReplacement);

        if ((newServerBase != oldServerBase)
                || (newUrlPrefix != oldUrlPrefix)) {
            logger.info("For Sesame download access point, replacing "
                    + "serverBase |" + oldServerBase
                    + "| with |" + newServerBase
                    + "| and urlPrefix |" + oldUrlPrefix
                    + "| with |" + newUrlPrefix + "|");
            if (TemporalUtils.isCurrent(ap)) {
                AccessPoint newAP = apCloneMapper.clone(ap);
                TemporalUtils.makeHistorical(ap, now);
                AccessPointDAO.updateAccessPoint(em, ap);
                ApSesameDownload newApSesameDownload =
                        apCloneMapper.clone(apSesameDownload);
                newApSesameDownload.setServerBase(newServerBase);
                newApSesameDownload.setUrlPrefix(newUrlPrefix);
                newAP.setData(JSONSerialization.serializeObjectAsJsonString(
                        newApSesameDownload));
                TemporalUtils.makeCurrentlyValid(newAP, now);
                AccessPointDAO.saveAccessPoint(em, newAP);
            } else {
                apSesameDownload.setServerBase(newServerBase);
                apSesameDownload.setUrlPrefix(newUrlPrefix);
                ap.setData(JSONSerialization.serializeObjectAsJsonString(
                        apSesameDownload));
                AccessPointDAO.updateAccessPoint(em, ap);
            }
        } else {
            logger.info("For Sesame download access point, leaving "
                    + "serverBase |" + oldServerBase + "| unchanged and "
                    + "urlPrefix |" + oldUrlPrefix + "| unchanged");
        }
    }

    /** Examine a sissvoc access point to see if it needs updating;
     * if so, make the existing instance historical, and add a new instance.
     * @param em The EntityManager to be used.
     * @param now The time to use as the value of "now" when
     *      applying changes to rows of the database.
     * @param beforeRepositoryLdaRegex The regular expression to use
     *      for finding a match within the "url-prefix" field.
     * @param afterRepositoryLdaReplacement The replacement value to use
     *      for matches within the "url-prefix" field.
     * @param apCloneMapper The mapper instance to use for cloning
     *      AccessPoint instances.
     * @param ap The access point to consider fixing.
     */
    public static void fixSissvoc(final EntityManager em,
            final LocalDateTime now,
            final String beforeRepositoryLdaRegex,
            final String afterRepositoryLdaReplacement,
            final AccessPointClone apCloneMapper,
            final AccessPoint ap) {
        ApSissvoc apSissvoc =
                JSONSerialization.deserializeStringAsJson(ap.getData(),
                        ApSissvoc.class);
        String oldUrlPrefix = apSissvoc.getUrlPrefix();
        String newUrlPrefix = oldUrlPrefix.replaceFirst(
                beforeRepositoryLdaRegex, afterRepositoryLdaReplacement);
        if (newUrlPrefix != oldUrlPrefix) {
            logger.info("For sissvoc access point, replacing "
                    + "urlPrefix |" + oldUrlPrefix
                    + "| with |" + newUrlPrefix + "|");
            if (TemporalUtils.isCurrent(ap)) {
                AccessPoint newAP = apCloneMapper.clone(ap);
                TemporalUtils.makeHistorical(ap, now);
                AccessPointDAO.updateAccessPoint(em, ap);
                ApSissvoc newApSissvoc = apCloneMapper.clone(apSissvoc);
                newApSissvoc.setUrlPrefix(newUrlPrefix);
                newAP.setData(JSONSerialization.serializeObjectAsJsonString(
                        newApSissvoc));
                TemporalUtils.makeCurrentlyValid(newAP, now);
                AccessPointDAO.saveAccessPoint(em, newAP);
            } else {
                apSissvoc.setUrlPrefix(newUrlPrefix);
                ap.setData(JSONSerialization.serializeObjectAsJsonString(
                        apSissvoc));
                AccessPointDAO.updateAccessPoint(em, ap);
            }
        } else {
            logger.info("For sissvoc access point, leaving "
                    + "urlPrefix |" + oldUrlPrefix + "| unchanged");
        }
    }

}
