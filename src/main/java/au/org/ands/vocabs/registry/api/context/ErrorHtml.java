/** See the file "LICENSE" for the full license governing this code. */

package au.org.ands.vocabs.registry.api.context;

import java.lang.invoke.MethodHandles;
import java.util.List;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.ResponseBuilder;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import au.org.ands.vocabs.registry.api.user.ErrorResult;

/** Handler for "internal server errors" generated by the webapp. */
@Path("/")
public class ErrorHtml {

    /** The path to a "splat" page that always generates an
     * "internal server error". Use for testing. */
    public static final String SPLAT = "splat";

    /** The message to be included in "internal server error" responses. */
    public static final String INTERNAL_ERROR = "Internal error";

    /** The message to be included in "internal server error" responses,
     * in HTML format. */
    public static final String INTERNAL_ERROR_HTML =
            "<html><body>" + INTERNAL_ERROR + "</body></html>";

    /** Logger for this class. */
    private final Logger logger = LoggerFactory.getLogger(
            MethodHandles.lookup().lookupClass());

    /** Resource for testing the handling of internal server errors.
     * @return There is no normal return from this method; it throws an
     *      Exception.
     * @throws Exception This method always throws an Exception.
     */
    @GET
    @Path(SPLAT)
    public Response splat() throws Exception {
        throw new Exception("Here's an exception.");
    }

    /** Return an error page for the webapp.
     * This method is invoked when the webapp generates an internal
     * server error.
     * The response is an {@link ErrorResult}, if the client
     * requested one of our known formats (i.e., JSON and XML).
     * If the client requested HTML, then an HTML response is provided;
     * otherwise, plain text is returned.
     * @param httpHeaders The HTTP headers of the original request.
     * @return The error response.
     */
    @Path("/error.html")
    @GET
    public Response errorHtml(@Context final HttpHeaders httpHeaders) {
        logger.error("In errorHtml");
        ResponseBuilder rb = Response.status(
                Response.Status.INTERNAL_SERVER_ERROR);

        MediaType mediaType = null;
        // The following is inspired by one of the answers at:
        // https://stackoverflow.com/questions/3227360/
        //         jax-rs-jersey-custom-exception-with-xml-or-json
        List<MediaType> acceptableMediaTypes =
                httpHeaders.getAcceptableMediaTypes();
        if (acceptableMediaTypes != null && acceptableMediaTypes.size() > 0) {
            for (MediaType acceptableMediaType : acceptableMediaTypes) {
                if (acceptableMediaType.equals(
                        MediaType.APPLICATION_JSON_TYPE)
                        || acceptableMediaType.equals(
                                MediaType.APPLICATION_XML_TYPE)) {
                    rb.entity(new ErrorResult(INTERNAL_ERROR));
                    mediaType = acceptableMediaType;
                    break;
                } else if (acceptableMediaType.equals(
                        MediaType.TEXT_HTML_TYPE)) {
                    rb.entity(INTERNAL_ERROR_HTML);
                    mediaType = acceptableMediaType;
                }
            }
        }
        if (mediaType != null) {
            rb = rb.type(mediaType);
        } else {
            rb.entity(INTERNAL_ERROR);
            rb.type(MediaType.TEXT_PLAIN_TYPE);
        }
        return rb.build();
    }

}
