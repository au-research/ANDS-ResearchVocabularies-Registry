<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE db-entity-map>
<db-entity-map>

  <!-- Only need to specify column elements if the camelcasing
       doesn't give the right result.
  -->

  <map tableName="vocabulary_ids"
       entityName="VocabularyId"
       serialVersionUID="-5030331935734628785L"
       >
    <!-- Column customization. Not needed for now.
         <column db="" field="" />
    -->
  </map>
  <map tableName="version_ids"
       entityName="VersionId"
       serialVersionUID="-8371217985547585670L"
       >
  </map>
  <map tableName="version_artefact_ids"
       entityName="VersionArtefactId"
       serialVersionUID="8396225985093911526L"
       >
  </map>
  <map tableName="access_point_ids"
       entityName="AccessPointId"
       serialVersionUID="-7135716758902970708L"
       >
  </map>
  <map tableName="related_entity_ids"
       entityName="RelatedEntityId"
       serialVersionUID="7857590494290614252L"
       >
  </map>
  <map tableName="related_entity_identifier_ids"
       entityName="RelatedEntityIdentifierId"
       serialVersionUID="664683346701966074L"
       >
  </map>
  <map tableName="vocabularies"
       entityName="Vocabulary"
       serialVersionUID="2667395213718191086L"
       >
    <idKey keyColumn="vocabulary_id" entityName="VocabularyId" />
    <column db="status" enum="VocabularyStatus" />
    <extraQueries>
      <extraQuery name="IS_SLUG_IN_USE">
        <extraQueryParameter name="slug" />
        <queryText temporal="true">
          SELECT COUNT(entity) > 0 FROM Vocabulary entity WHERE
          slug = :slug AND (
          #TEMPORAL_QUERY_VALID_CLAUSE
          OR
          #TEMPORAL_QUERY_ALL_DRAFT_CLAUSE
          )
        </queryText>
        <method>    /** Is a certain slug already in use, either for a
       published or draft vocabulary?
     * @param slug The slug to be looked up.
     * @return true, if the slug is already in use by a published
     *   or draft vocabulary.
     */
    public static boolean isSlugInUse(final String slug) {
        EntityManager em = DBContext.getEntityManager();
        TypedQuery&lt;Boolean&gt; q = em.createNamedQuery(
                Vocabulary.IS_SLUG_IN_USE, Boolean.class)
                .setParameter(Vocabulary.IS_SLUG_IN_USE_SLUG, slug);
        q = TemporalUtils.setDatetimeConstantParameters(q);
        Boolean slugInUse = q.getSingleResult();
        em.close();
        return slugInUse;
    }

</method>
      </extraQuery>
    </extraQueries>
  </map>
  <map tableName="versions"
       entityName="Version"
       serialVersionUID="-9118585204277776513L"
       >
    <idKey keyColumn="version_id" entityName="VersionId" />
    <column db="status" enum="VersionStatus" />
    <foreignKeyQueries>
      <foreignKeyQuery keyColumn="vocabularyId" entityName="Vocabulary" />
    </foreignKeyQueries>
  </map>
  <map tableName="version_artefacts"
       entityName="VersionArtefact"
       serialVersionUID="-1298821649186846122L"
       >
    <idKey keyColumn="version_artefact_id" entityName="VersionArtefactId" />
    <column db="status" enum="VersionArtefactStatus" />
    <column db="type" enum="VersionArtefactType" />
  </map>
  <map tableName="access_points"
       entityName="AccessPoint"
       serialVersionUID="6332868269699981887L"
       >
    <idKey keyColumn="access_point_id" entityName="AccessPointId" />
    <column db="type" enum="AccessPointType" />
    <foreignKeyQueries>
      <foreignKeyQuery keyColumn="versionId" entityName="Version" />
    </foreignKeyQueries>
  </map>
  <map tableName="related_entities"
       entityName="RelatedEntity"
       serialVersionUID="-4871628368369543812L"
       >
    <idKey keyColumn="related_entity_id" entityName="RelatedEntityId" />
    <column db="type" enum="RelatedEntityType" />
    <extraQueries>
      <extraQuery name="GET_RELATED_ENTITY_LIST_FOR_VOCABULARY">
        <extraQueryParameter name="vocabularyId" />
        <queryText temporal="true">
          SELECT entity FROM RelatedEntity entity WHERE
          relatedEntityId IN (SELECT relatedEntityId FROM
          VocabularyRelatedEntity WHERE vocabularyId = :vocabularyId
          #AND_TEMPORAL_QUERY_VALID_SUFFIX
          )
          #AND_TEMPORAL_QUERY_VALID_SUFFIX
        </queryText>
        <method>    /** Get all current RelatedEntity instances for a vocabulary.
     * @param vocabularyId The vocabulary id for which related
     *     entities are to be looked up.
     * @return An list of all RelatedEntity instances for the vocabulary.
     */
    public static List&lt;RelatedEntity&gt;
        getCurrentRelatedEntitiesForVocabulary(final int vocabularyId) {
        EntityManager em = DBContext.getEntityManager();
        TypedQuery&lt;RelatedEntity&gt; q = em.createNamedQuery(
                RelatedEntity.
                    GET_RELATED_ENTITY_LIST_FOR_VOCABULARY,
                RelatedEntity.class)
                .setParameter(RelatedEntity.
                    GET_RELATED_ENTITY_LIST_FOR_VOCABULARY_VOCABULARYID,
                    vocabularyId);
        q = TemporalUtils.setDatetimeConstantParameters(q);
        List&lt;RelatedEntity&gt; entityList = q.getResultList();
        em.close();
        return entityList;
    }

</method>
      </extraQuery>
    </extraQueries>
  </map>
  <map tableName="related_entity_identifiers"
       entityName="RelatedEntityIdentifier"
       serialVersionUID="-4092084965564024230L"
       >
    <idKey keyColumn="related_entity_identifier_id"
           entityName="RelatedEntityIdentifierId" />
    <column db="identifier_type" enum="RelatedEntityIdentifierType" />
    <foreignKeyQueries>
      <foreignKeyQuery keyColumn="relatedEntityId" entityName="RelatedEntity" />
    </foreignKeyQueries>
  </map>
  <map tableName="vocabulary_related_entities"
       entityName="VocabularyRelatedEntity"
       serialVersionUID="-8491635774415411143L"
       >
    <column db="relation" enum="RelatedEntityRelation" />
  </map>
  <map tableName="vocabulary_related_vocabularies"
       entityName="VocabularyRelatedVocabulary"
       serialVersionUID="-9169766097390954402L"
       >
    <column db="relation" enum="RelatedVocabularyRelation" />
  </map>
  <map tableName="tasks"
       entityName="Task"
       serialVersionUID="3258582216313958016L"
       >
    <column db="status" enum="TaskStatus" />
  </map>
  <map tableName="poolparty_servers"
       entityName="PoolPartyServer"
       serialVersionUID="8549740134610632315L"
       >
  </map>
<!--
  <map tableName="vocabulary_events"
       entityName="VocabularyEvent"
       serialVersionUID="5339415610349523516L"
       >
  </map>
-->
  <map tableName="registry_events"
       entityName="RegistryEvent"
       serialVersionUID="-2085702449839519639L"
       >
    <column db="element_type" enum="RegistryEventElementType" />
  </map>
  <map tableName="resource_owner_hosts"
       entityName="ResourceOwnerHost"
       serialVersionUID="-2913007035002774527L"
       >
  </map>
  <map tableName="resource_map"
       entityName="ResourceMapEntry"
       serialVersionUID="-7521129755199622960L"
       >
  </map>
  <map tableName="subject_resolver_sources"
       entityName="SubjectResolverSource"
       serialVersionUID="-3935011431416885320L"
       >
  </map>
  <map tableName="subject_resolver"
       entityName="SubjectResolverEntry"
       serialVersionUID="-7882031463978706641L"
       >
    <extraQueries>
      <extraQuery name="DOES_SUBJECT_RESOLVE">
        <extraQueryParameter name="source" />
        <extraQueryParameter name="iri" />
        <queryText>
          SELECT COUNT(entity) > 0 FROM SubjectResolverEntry entity WHERE
          source = :source AND iri = :iri
        </queryText>
        <method>    /** Does a subject resolve?
     * @param source The vocabulary source for the subject.
     * @param iri The IRI of the subject being looked up.
     * @return true, if the source/IRI is valid.
     */
    public static boolean
        doesSubjectResolve(final String source, final String iri) {
        EntityManager em = DBContext.getEntityManager();
        TypedQuery&lt;Boolean&gt; q = em.createNamedQuery(
                SubjectResolverEntry.DOES_SUBJECT_RESOLVE,
                Boolean.class)
                .setParameter(SubjectResolverEntry.
                    DOES_SUBJECT_RESOLVE_SOURCE, source)
                    .setParameter(SubjectResolverEntry.
                    DOES_SUBJECT_RESOLVE_IRI, iri);
        Boolean subjectValid = q.getSingleResult();
        em.close();
        return subjectValid;
    }

</method>
      </extraQuery>
      <extraQuery name="GET_SUBJECT_RESOLVED">
        <extraQueryParameter name="source" />
        <extraQueryParameter name="iri" />
        <queryText>
          SELECT entity FROM SubjectResolverEntry entity WHERE
          source = :source AND iri = :iri
        </queryText>
        <method>    /** Get the SubjectResolverEntry instances for a subject.
     * @param source The vocabulary source for the subject.
     * @param iri The IRI of the subject being looked up.
     * @return An list of all SubjectResolverEntry instances for the subject.
     */
    public static List&lt;SubjectResolverEntry&gt;
        getSubjectResolverEntries(final String source, final String iri) {
        EntityManager em = DBContext.getEntityManager();
        TypedQuery&lt;SubjectResolverEntry&gt; q = em.createNamedQuery(
                SubjectResolverEntry.
                    GET_SUBJECT_RESOLVED,
                SubjectResolverEntry.class)
                .setParameter(SubjectResolverEntry.
                    GET_SUBJECT_RESOLVED_SOURCE,
                    source)
                .setParameter(SubjectResolverEntry.
                    GET_SUBJECT_RESOLVED_IRI,
                    iri);
        List&lt;SubjectResolverEntry&gt; entityList = q.getResultList();
        em.close();
        return entityList;
    }

</method>
      </extraQuery>
      <extraQuery name="DELETE_ALL_ENTRIES" type="update">
        <queryText>
          DELETE FROM SubjectResolverEntry entity
        </queryText>
        <method>    /** Delete all resolver entries.
     */
    public static void deleteAllResolverEntries() {
        EntityManager em = DBContext.getEntityManager();
        em.getTransaction().begin();
        Query q = em.createNamedQuery(SubjectResolverEntry.
                    DELETE_ALL_ENTRIES);
        q.executeUpdate();
        em.getTransaction().commit();
        em.close();
    }

</method>
      </extraQuery>
    </extraQueries>
  </map>

</db-entity-map>
